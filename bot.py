import os
import logging
from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from flask import Flask, request, jsonify
import redis
import json
import asyncio # Necess√°rio para create_task e para rodar funcoes async

# Configura√ß√£o de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Configura√ß√µes do bot - Carregadas de vari√°veis de ambiente
BOT_TOKEN = os.environ.get("BOT_TOKEN")
WEBHOOK_URL = os.environ.get("WEBHOOK_URL")
REDIS_URL = os.environ.get("REDIS_URL")
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
ADMIN_CHAT_ID = os.environ.get("ADMIN_CHAT_ID") # Adicione esta vari√°vel de ambiente no Render
BOT_USERNAME = os.environ.get("BOT_USERNAME", "botchopp_bot") # Nome de usu√°rio do bot para mensagens de erro

# Verifica√ß√£o de vari√°veis de ambiente essenciais
if not BOT_TOKEN:
    logger.critical("BOT_TOKEN n√£o est√° configurado. O bot n√£o pode iniciar.")
    exit(1)
if not WEBHOOK_URL:
    logger.critical("WEBHOOK_URL n√£o est√° configurado. O bot n√£o pode iniciar.")
    exit(1)
if not REDIS_URL:
    logger.critical("REDIS_URL n√£o est√° configurado. O bot n√£o pode iniciar.")
    exit(1)
if not GEMINI_API_KEY:
    logger.warning("GEMINI_API_KEY n√£o est√° configurado. A funcionalidade Gemini pode estar limitada.")

# Fun√ß√£o para enviar mensagem ao administrador (definida antes da conex√£o Redis para uso imediato)
# Note: Esta fun√ß√£o ainda √© ass√≠ncrona e precisa de um loop de eventos.
# Para chamadas cr√≠ticas na inicializa√ß√£o *antes* do loop, a abordagem s√≠ncrona ou log √© prefer√≠vel.
async def send_admin_message(message_text: str):
    if ADMIN_CHAT_ID:
        try:
            bot = Bot(token=BOT_TOKEN)
            await bot.send_message(chat_id=ADMIN_CHAT_ID, text=message_text)
            logger.info(f"Mensagem de administrador enviada com sucesso para {ADMIN_CHAT_ID}")
        except Exception as e:
            logger.error(f"Falha ao enviar mensagem de administrador para {ADMIN_CHAT_ID}: {e}")
    else:
        logger.warning("ADMIN_CHAT_ID n√£o est√° configurado. N√£o √© poss√≠vel enviar mensagens de administrador.")

# Conex√£o com o Redis
# Removendo a chamada `asyncio.create_task` aqui, pois este √© um ponto cr√≠tico
# antes do loop de eventos principal do Uvicorn estar ativo.
# O `exit(1)` j√° garante que o servi√ßo n√£o continue se o Redis n√£o estiver acess√≠vel.
try:
    redis_conn = redis.from_url(REDIS_URL)
    redis_conn.ping()  # Testa a conex√£o
    logger.info("Conectado ao Redis com sucesso!")
except Exception as e: # Capture Exception para pegar TypeErrors e ConnectionErrors
    logger.critical(f"ERRO CR√çTICO: N√£o foi poss√≠vel conectar ao Redis em {REDIS_URL}. O bot n√£o poder√° iniciar. Erro: {e}.")
    # Se voc√™ *realmente* precisa enviar uma mensagem de admin aqui, ela teria que ser s√≠ncrona
    # ou o servi√ßo teria que ser iniciado de forma diferente. Por simplicidade e robustez,
    # neste ponto, vamos confiar nos logs e no `exit(1)`.
    exit(1) # Finaliza a execu√ß√£o se n√£o conseguir conectar ao Redis

# Carregar base de conhecimento (exemplo de como carregar um JSON)
FAQ_DATA = {}
try:
    with open("base_conhecimento/faq_data.json", "r", encoding="utf-8") as f:
        FAQ_DATA = json.load(f)
    logger.info("Base de conhecimento FAQ carregada com sucesso.")
except FileNotFoundError:
    logger.error("Arquivo base_conhecimento/faq_data.json n√£o encontrado. A base de conhecimento n√£o ser√° utilizada.")
except json.JSONDecodeError:
    logger.error("Erro ao decodificar base_conhecimento/faq_data.json. Verifique a formata√ß√£o do JSON.")
except Exception as e:
    logger.error(f"Erro inesperado ao carregar base de conhecimento: {e}")

# Inicializar o aplicativo Flask
app = Flask(__name__)

# Inicializar o bot do Telegram
application = Application.builder().token(BOT_TOKEN).build()

# Handlers do Telegram (exemplo de implementa√ß√£o, adapte conforme sua l√≥gica)
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Envia uma mensagem quando o comando /start √© emitido."""
    await update.message.reply_text("Ol√°! Eu sou o BotChopp. Como posso ajudar?")
    logger.info(f"Comando /start recebido de {update.effective_user.id}")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Processa mensagens de texto."""
    user_message = update.message.text
    if user_message: # Garante que h√° texto na mensagem
        user_message_lower = user_message.lower()
        response = "Desculpe, n√£o entendi. Tente perguntar de outra forma."

        # Tenta buscar na FAQ
        found_in_faq = False
        for entry in FAQ_DATA.get("perguntas_frequentes", []):
            if any(keyword in user_message_lower for keyword in entry["palavras_chave"]):
                response = entry["resposta"]
                found_in_faq = True
                break
        
        # Se n√£o encontrar na FAQ, pode passar para o Gemini (ou outra IA)
        if not found_in_faq and GEMINI_API_KEY:
            try:
                # Aqui voc√™ integraria com a API do Gemini
                # Ex: response = await call_gemini_api(user_message, GEMINI_API_KEY)
                # Por enquanto, √© apenas um placeholder:
                response = f"Voc√™ perguntou: '{user_message}'. (A integra√ß√£o com Gemini vir√° aqui em breve!)"
                logger.info(f"Mensagem processada por Gemini placeholder para {update.effective_user.id}")
            except Exception as e:
                logger.error(f"Erro ao chamar API Gemini: {e}")
                response = "No momento, n√£o consigo processar sua solicita√ß√£o com a IA. Tente mais tarde."
        elif not found_in_faq and not GEMINI_API_KEY:
             response = "N√£o consigo responder a essa pergunta. A chave Gemini API n√£o est√° configurada."

        await update.message.reply_text(response)
        logger.info(f"Mensagem de {update.effective_user.id}: '{user_message}' - Resposta: '{response}'")
    else:
        logger.warning(f"Mensagem sem texto recebida de {update.effective_user.id}")
        await update.message.reply_text("Recebi sua mensagem, mas parece que ela n√£o cont√©m texto.")


# Adicionar handlers ao dispatcher do application
application.add_handler(CommandHandler("start", start))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))


# Rota para receber atualiza√ß√µes do webhook
@app.route("/", methods=["POST"])
async def webhook_handler():
    """Lida com as requisi√ß√µes POST do webhook do Telegram."""
    if request.method == "POST":
        json_data = request.get_json(force=True)
        update = Update.de_json(json_data, application.bot)
        
        try:
            # `application.process_update` j√° lida com a execu√ß√£o ass√≠ncrona
            # dentro do contexto do loop de eventos do Uvicorn/Flask.
            await application.process_update(update)
            logger.info(f"Update do Telegram processado com sucesso para update_id {update.update_id}")
        except Exception as e:
            logger.error(f"Erro ao processar update do Telegram {update.update_id}: {e}", exc_info=True)
            # Aqui, como j√° estamos dentro de um loop de eventos, podemos usar asyncio.create_task
            asyncio.create_task(send_admin_message(f"üö® Erro no bot '{BOT_USERNAME}' ao processar update {update.update_id}: {e}"))
        return "ok"
    return "ok"

# Rota de health check para o Render
@app.route("/health", methods=["GET"])
def health_check():
    """Endpoint para verificar a sa√∫de do servi√ßo."""
    logger.info("Health check solicitado.")
    return "Bot is running", 200

# Execu√ß√£o do aplicativo Flask (para o Gunicorn/Uvicorn)
if __name__ == '__main__':
    # Este bloco √© executado quando o script √© rodado diretamente (e.g., python bot.py).
    # No Render, o Gunicorn/Uvicorn que inicializa o 'app'.
    # A configura√ß√£o do webhook deve ser feita no script de inicializa√ß√£o do Render (startup.sh)
    # ou por uma chamada API √∫nica, n√£o a cada inicializa√ß√£o do processo worker.
    async def set_my_webhook():
        try:
            bot = Bot(token=BOT_TOKEN)
            webhook_info = await bot.get_webhook_info()
            if webhook_info.url != WEBHOOK_URL:
                await bot.set_webhook(url=WEBHOOK_URL)
                logger.info(f"Webhook configurado para: {WEBHOOK_URL}")
            else:
                logger.info("Webhook j√° est√° configurado corretamente.")
        except Exception as e:
            logger.error(f"Falha ao configurar o webhook: {e}", exc_info=True)
            # Aqui, se n√£o houver um loop, a mensagem n√£o ser√° enviada.
            # Para testes locais, pode ser √∫til. Em produ√ß√£o, confie nos logs.
            print(f"ERRO: Falha ao configurar o webhook na inicializa√ß√£o: {e}")

    # Tenta configurar o webhook. `asyncio.run()` cria um novo loop de eventos
    # e s√≥ deve ser usado se *n√£o* houver um loop rodando.
    # No ambiente de produ√ß√£o com Gunicorn/Uvicorn, o loop de eventos j√° √© gerenciado.
    # Se voc√™ executa este script com `python bot.py`, ele funcionar√°.
    # Se for pelo Gunicorn, esta parte ser√° ignorada ou causar√° o erro.
    # A maneira mais limpa para o Render √© chamar o `set_webhook` APENAS NO SEU STARTUP COMMAND.
    # Vou manter o `asyncio.run` para o uso local, mas ciente que Gunicorn n√£o usar√° isso.
    try:
        if os.environ.get("RUN_FLASK_LOCALLY") == "true" or not os.environ.get("RENDER"):
            # Este √© um hack para rodar localmente ou quando n√£o estiver no Render
            # e realmente querer que o bot inicie o loop Flask.
            # Para produ√ß√£o no Render, a linha `app.run` e `asyncio.run(set_my_webhook())`
            # *n√£o ser√£o executadas* porque o Gunicorn importa `app` diretamente.
            asyncio.run(set_my_webhook())
            port = int(os.environ.get("PORT", 5000))
            logger.info(f"Iniciando aplicativo Flask na porta {port}")
            app.run(host="0.0.0.0", port=port)
        else:
            logger.info("Executando no ambiente Render. Gunicorn/Uvicorn gerenciar√° a execu√ß√£o.")
            # N√£o chame app.run() ou asyncio.run() aqui, pois o Gunicorn/Uvicorn far√° isso.
            # O Render assume que seu `gunicorn bot:app` no `Start Command`
            # √© o suficiente para iniciar a aplica√ß√£o.
            pass # O Gunicorn ir√° importar `app` e inici√°-lo.
    except RuntimeError as e:
        logger.warning(f"N√£o foi poss√≠vel configurar o webhook via asyncio.run (provavelmente o loop de eventos j√° est√° ativo pelo Uvicorn/Gunicorn): {e}")
    except Exception as e:
        logger.error(f"Erro inesperado ao tentar configurar o webhook na inicializa√ß√£o local: {e}", exc_info=True)
